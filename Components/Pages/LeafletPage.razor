@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@rendermode InteractiveServer
@page "/"

<div class="map-container">
    <div id="map"></div>
    <div class="button-overlay">
        <button class="btn btn-primary" @onclick="BackButton">Back</button>
        <button class="btn btn-secondary" @onclick="NextButton">Next</button>
    </div>
    <InputFile OnChange="@SingleUpload" accept=".ics" class="file-upload"/>
</div>

@if (errors.Count > 0) {
    <h2>Logging</h2>
    <ul class="="text-danger>
        @foreach (var error in errors) {
            <li>@error</li>
        }
    </ul>
}

@code {
    private IJSObjectReference? module;
    private List<string> errors = new();
    private List<Route> routes = [];
    private int index = 0;
    
    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender) {
            return;
        }
        module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./leafletmap.js");
        if (module != null) {
            await module.InvokeAsync<string>("load_map");
        }
    }
    
    async ValueTask IAsyncDisposable.DisposeAsync() {
        if (module is not null) {
            await module.DisposeAsync();
        }
    }

    private async Task DrawRoute(string geoJson, string color = "blue", double opacity = 1) {
        if (module != null) {
            await module.InvokeAsync<string>("draw_route", geoJson, color, opacity);
            
        }
    }

    private async Task ClearRoutes() {
        if (module != null) {
            await module.InvokeAsync<string>("clear_map");
        }
    }

    private async Task DrawAllRoutes() {
        await ClearRoutes();
        for (int i = 0; i < routes.Count; i++) {
            if (i == index) continue;
            Route route = routes[i];
            if (route.IsComputed()) {
                await DrawRoute(route.GetGeoJson(), "gray", 0.5);
            }
        }
        await DrawRoute(routes[index].GetGeoJson(), "blue");
    }
    private async Task SingleUpload(InputFileChangeEventArgs e) {
        try {
            string newFileName = Path.ChangeExtension(Path.GetRandomFileName(), Path.GetExtension(e.File.Name));
            string path = Path.Combine("./uploads", newFileName);
            Directory.CreateDirectory("./uploads");
            await using (FileStream fs = new(path, FileMode.Create)) {
                await e.File.OpenReadStream().CopyToAsync(fs);
            }

            string calenderText = File.ReadAllText(path);
            Directory.Delete("./uploads", true);
            var calendar = Ical.Net.Calendar.Load(calenderText);
            await ProcessCalendar(calendar);
        } catch (Exception ex) {
            errors.Add(ex.Message);
        }
    }

    private async Task ProcessCalendar(Ical.Net.Calendar calendar) {
        Schedule schedule = new(calendar);
        for (int i = 0; i < schedule.GetClasses(DayOfWeek.Monday).Count - 1; i++) {
            Class startClass = schedule.GetClasses()[i];
            Class destinationClass = schedule.GetClasses()[i + 1];
            if (startClass.location == destinationClass.location) continue;
            Route route = schedule.GetClasses()[i].CreateRoute(schedule.GetClasses()[i + 1]);
            await route.SendRequestAsync();
            routes.Add(route);
        }
        await DrawAllRoutes();
    }

    private async Task NextButton() {
        if (index < routes.Count - 1) {
            index++;
            await DrawAllRoutes();
        }
    }

    private async Task BackButton() {
        if (index > 0) {
            index--;
            await DrawAllRoutes();
        }
    }
}